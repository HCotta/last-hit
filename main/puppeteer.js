const { ipcMain, BrowserWindow } = require('electron');
const puppeteer = require('puppeteer');
const uuidv4 = require('uuid/v4');
const pti = require('puppeteer-to-istanbul');

const getChromiumExecPath = () => {
	return puppeteer.executablePath().replace('app.asar', 'app.asar.unpacked');
};

/** stop pick dom from page */
const createPageWindowEventRecorder = flowKey => (eventJsonStr, onPickDOM) => {
	if (!eventJsonStr) {
		console.warn('Argument is null.');
		return;
	}
	try {
		const windows = BrowserWindow.getAllWindows();
		const jsonEvent = JSON.parse(eventJsonStr);
		if (onPickDOM) {
			windows[0].show();
			windows[0].focus();
			windows[0].focusOnWebView();
			windows[0].webContents.send(`dom-on-page-picked`, { path: jsonEvent.path });
		} else {
			windows[0].webContents.send(`message-captured-${flowKey}`, jsonEvent);
		}
	} catch (e) {
		console.error(e);
	}
};
const captureScreenshot = async page => {
	// wait for ui render
	// await page.waitForNavigation({ waitUntil: 'networkidle2' });
	return await page.screenshot({ encoding: 'base64' });
};
// expose function to given page
const exposeFunctionToPage = async (page, flowKey, allPages) => {
	const uuid = findUuidOfPage(page, allPages);
	await page.exposeFunction('$lhGetUuid', () => uuid);
	await page.exposeFunction('$lhGetFlowKey', () => {
		return flowKey;
	});
	await page.exposeFunction('$lhRecordEvent', createPageWindowEventRecorder(flowKey));
};
/**
 * install listeners on given page
 * @param {Page} page
 */
const installListenersOnPage = async page => {
	await page.evaluateOnNewDocument(() => {
		// here we are in the browser context
		const createXPathFromElement = elm => {
			var allNodes = document.getElementsByTagName('*');
			for (var segs = []; elm && elm.nodeType == 1; elm = elm.parentNode) {
				if (elm.hasAttribute('id') && !/^md-.+-.{6,16}$/.test(elm.getAttribute('id'))) {
					var uniqueIdCount = 0;
					for (var n = 0; n < allNodes.length; n++) {
						if (allNodes[n].hasAttribute('id') && allNodes[n].id == elm.id) {
							uniqueIdCount++;
						}
						if (uniqueIdCount > 1) {
							break;
						}
					}
					if (uniqueIdCount == 1) {
						segs.unshift('//*[@id="' + elm.getAttribute('id') + '"]');
						return segs.join('/');
					} else {
						segs.unshift(elm.localName.toLowerCase() + '[@id="' + elm.getAttribute('id') + '"]');
					}
					// } else if (elm.hasAttribute('class')) {
					// 	segs.unshift(elm.localName.toLowerCase() + '[@class="' + elm.getAttribute('class') + '"]');
				} else {
					for (i = 1, sib = elm.previousSibling; sib; sib = sib.previousSibling) {
						if (sib.localName == elm.localName) i++;
					}
					if (i > 1) {
						segs.unshift(elm.localName.toLowerCase() + '[' + i + ']');
					} else {
						segs.unshift(elm.localName.toLowerCase());
					}
				}
			}
			return segs.length ? '/' + segs.join('/') : null;
		};

		const transformEvent = (e, element) => {
			let xpath = createXPathFromElement(element);
			if (e.type === 'click' && xpath.indexOf('/svg') !== -1) {
				const newXpath = xpath.replace(/^(.*button.*)\/svg.*$/, '$1');
				if (newXpath !== xpath) {
					// replaced
					let parent = element;
					while (parent.tagName !== 'BUTTON') {
						parent = parent.parentElement;
					}
					element = parent;
				}
			}
			return {
				// keys
				altKey: e.altKey,
				ctrlKey: e.ctrlKey,
				metaKey: e.metaKey,
				shiftKey: e.shiftKey,
				// mouse buttons
				button: e.button,
				buttons: e.buttons,
				detail: e.detail,
				/** positions */
				clientX: e.clientX,
				clientY: e.clientY,
				pageX: e.pageX,
				pageY: e.pageY,
				screenX: e.screenX,
				screenY: e.screenY,
				scrollTop: element === document ? document.documentElement.scrollTop : element.scrollTop,
				scrollLeft: element === document ? document.documentElement.scrollLeft : element.scrollLeft,
				timeStamp: e.timeStamp,
				type: e.type,
				// event source. true: generated by user action; false: generated by scripts
				isTrusted: e.isTrusted,
				value: element.value,
				// computed
				path: xpath,
				target:
					element === document
						? 'document'
						: `<${element.tagName.toLowerCase()} ${element
								.getAttributeNames()
								.map(name => `${name}="${element.getAttribute(name)}"`)
								.join(' ')}>`
				// bubbles: e.bubbles,
				// cancelBubble: e.cancelBubble,
				// cancelable: e.cancelable,
				// composed: e.composed,
				// currentTarget: e.currentTarget && e.currentTarget.outerHTML,
				// defaultPrevented: e.defaultPrevented,
				// eventPhase: e.eventPhase,
				// fromElement: e.fromElement && e.fromElement.outerHTML,
				// layerX: e.layerX,
				// layerY: e.layerY,
				// movementX: e.movementX,
				// movementY: e.movementY,
				// offsetX: e.offsetX,
				// offsetY: e.offsetY,
				// relatedTarget: e.relatedTarget && e.relatedTarget.outerHTML,

				// sourceCapabilities: e.sourceCapabilities && e.sourceCapabilities.toString(),
				// toElement: e.toElement && e.toElement.outerHTML,
				// view: e.view && e.view.toString(),
				// which: e.which,
				// x: e.x,
				// y: e.y,
			};
		};
		let scrollTimeoutHandle;
		const eventHandler = e => {
			if (!e) {
				return;
			}
			if (['STYLE'].includes(e.target && e.target.tagName)) {
				// inline style tag, ignored
				return;
			}
			const mask = document.getElementById('$lh-mask');
			const isOnMask = e.target === mask;
			if (isOnMask && e.type !== 'click') {
				// on pick dom mode, only click is cared,
				// otherwise ignored
				return;
			}

			let element = e.target;
			if (isOnMask) {
				document.body.removeChild(mask);
				const { clientX, clientY } = event;
				const elements = document.elementsFromPoint(clientX, clientY);
				if (elements.length > 1) {
					element = elements[1];
				}
			}

			const data = transformEvent(e, element);
			data.uuid = window.$lhUuid;
			if (e.type === 'scroll') {
				if (scrollTimeoutHandle) {
					clearTimeout(scrollTimeoutHandle);
				}
				scrollTimeoutHandle = setTimeout(() => {
					window.$lhRecordEvent(JSON.stringify(data), isOnMask);
					scrollTimeoutHandle = null;
				}, 100);
			} else {
				window.$lhRecordEvent(JSON.stringify(data), isOnMask);
			}
		};

		window.$lhGetUuid().then(uuid => {
			window.$lhUuid = uuid;
		});

		Object.values({
			CLICK: 'click',
			// DBLCLICK: 'dblclick',
			CHANGE: 'change',
			// KEYDOWN: 'keydown',
			// SELECT: 'select'
			FOCUS: 'focus',
			SCROLL: 'scroll',
			// onchange:"on-change",
			MOUSE_DOWN: 'mousedown',
			SUBMIT: 'submit'
			// LOAD: 'load',
			// UNLOAD: 'unload',
			// VALUE_CHANGE: 'valuechange'
		}).forEach(eventType => document.addEventListener(eventType, eventHandler, { capture: true }));
	});
};

const staticResourceTypes = [
	'document',
	'stylesheet',
	'image',
	'media',
	'font',
	'script',
	'texttrack',
	'eventsource',
	'manifest',
	'other'
];
const dynamicResourceTypes = ['xhr', 'fetch', 'websocket'];
const isDynamicResource = resourceType => dynamicResourceTypes.includes(resourceType);
const recordRemoteRequests = async (page, flowKey, allPages) => {
	const sendRecordedEvent = createPageWindowEventRecorder(flowKey);
	page.on('response', async response => {
		const url = response.url();
		const request = response.request();
		const resourceType = request.resourceType();

		if (isDynamicResource(resourceType)) {
			// dynamic resources
			try {
				sendRecordedEvent(
					JSON.stringify({
						type: 'ajax',
						uuid: findUuidOfPage(page, allPages),
						request: {
							url,
							method: request.method(),
							headers: request.headers(),
							body: request.postData(),
							resourceType
						},
						response: {
							statusCode: response.status(),
							statusMessage: response.statusText(),
							headers: response.headers(),
							body: await response.text()
						}
					})
				);
			} catch (err) {
				console.error(`Failed getting data from: ${url}`);
				console.error(err);
			}
		} else {
			// static resource
			// IMPORTANT IGNORED NOW, BECAUSE OF PREFORMANCE ISSUE IN RENDERERING
			// try {
			// 	sendRecordedEvent(
			// 		JSON.stringify({
			// 			type: 'resource-load',
			// 			request: { url, method: request.method(), resourceType },
			// 			response: {
			// 				statusCode: response.status(),
			// 				statusMessage: response.statusText()
			// 			}
			// 		})
			// 	);
			// } catch (err) {
			// 	console.error(`Failed getting data from: ${url}`);
			// 	console.error(err);
			// }
		}
	});
};

const isAllRelatedPagesClosed = async (page, flowKey) => {
	const allPages = await page.browser().pages();
	return (
		allPages
			.filter(p => page !== p)
			.filter(async p => {
				const key = await page.evaluate(() => window.$lhGetFlowKey());
				return key === flowKey;
			}).length === 0
	);
};
const findUuidOfPage = (page, allPages) => {
	return Object.keys(allPages).find(uuid => allPages[uuid] === page);
};
const deletePageByUuid = (page, allPages) => {
	const uuid = findUuidOfPage(page, allPages);
	delete allPages[uuid];
	return uuid;
};
/**
 *
 * @param {Page} page
 * @param {{device, flowKey}} options
 * @param {{uuid: Page}} allPages
 */
const controlPage = async (page, options, allPages) => {
	const { device, flowKey } = options;
	const sendRecordedEvent = createPageWindowEventRecorder(flowKey);
	await exposeFunctionToPage(page, flowKey, allPages);
	await installListenersOnPage(page, flowKey);
	await page.emulate(device);
	await page.emulateMedia('screen');
	const setBackground = () => (document.documentElement.style.backgroundColor = 'rgba(25,25,25,0.8)');
	await page.evaluate(setBackground);

	// Enable both JavaScript and CSS coverage
	await page.coverage.startJSCoverage();
	await page.coverage.startCSSCoverage();

	page.on('load', async () => {
		await page.evaluate(setBackground);
	});
	page.on('close', async () => {
		// RESEARCH already closed? seems like this.
		// traverse all pages to check all related pages were closed or not
		const allClosed = isAllRelatedPagesClosed(page, flowKey);
		const uuid = deletePageByUuid(page, allPages);
		if (uuid) {
			sendRecordedEvent(JSON.stringify({ type: 'page-closed', url: page.url(), allClosed, uuid }));
		}
	});
	// page created by window.open or anchor
	page.on('popup', async newPage => {
		console.log('page event popup caught');
		if (Object.values(allPages).indexOf(newPage) === -1) {
			// not found in pages
			const uuid = uuidv4();
			allPages[uuid] = newPage;
			controlPage(newPage, { device, flowKey }, allPages);
			const base64 = await captureScreenshot(newPage);
			sendRecordedEvent(JSON.stringify({ type: 'page-created', url: newPage.url(), image: base64, uuid }));
		}
	});
	page.on('dialog', async dialog => {
		console.log(`page event dialog caught`);
		const base64 = await captureScreenshot(page);
		const uuid = findUuidOfPage(page, allPages);
		sendRecordedEvent(JSON.stringify({ type: 'dialog-open', url: page.url(), image: base64, uuid }));
	});
	page.on('pageerror', async () => {
		console.log(`page event pageerror caught`);
		const base64 = await captureScreenshot(page);
		const uuid = findUuidOfPage(page, allPages);
		sendRecordedEvent(JSON.stringify({ type: 'page-error', url: page.url(), image: base64, uuid }));
	});
};

const browsers = {};
const launch = () => {
	ipcMain.on('launch-puppeteer', (event, arg) => {
		(async () => {
			const { url, device, flowKey, uuid } = arg;
			const {
				viewport: { width, height }
			} = device;
			const chrome = { x: 0, y: 200 };
			const browserArgs = [];
			browserArgs.push(`--window-size=${width + chrome.x},${height + chrome.y}`);
			browserArgs.push('--disable-infobars');
			// browserArgs.push('--use-mobile-user-agent');

			// create browser
			const browser = await puppeteer.launch({
				headless: false,
				executablePath: getChromiumExecPath(),
				args: browserArgs
			});
			// cache browser on global
			browsers[flowKey] = browser;
			// check which page will be used
			const pages = await browser.pages();
			if (pages != null && pages.length > 0) {
				await pages[0].close();
			}
			const page = await browser.newPage();
			pages.push(page);
			// give uuid to pages
			const allPages = {
				[uuid]: page
			};

			const sendRecordedEvent = createPageWindowEventRecorder(flowKey);
			browser.on('disconnected', () => {
				sendRecordedEvent(JSON.stringify({ type: 'end' }));
			});
			browser.on('targetcreated', async newTarget => {
				if (newTarget.type() === 'page') {
					console.log('browser target created caught');
					const newPage = await newTarget.page();
					if (Object.values(allPages).indexOf(newPage) === -1) {
						// not found in pages
						const uuid = uuidv4();
						allPages[uuid] = newPage;
						controlPage(newPage, { device, flowKey }, allPages);

						const base64 = await captureScreenshot(newPage);
						sendRecordedEvent(
							JSON.stringify({ type: 'page-created', url: newPage.url(), image: base64, uuid })
						);
					}
				}
			});
			browser.on('targetchanged', async target => {
				if (target.type() === 'page') {
					console.log('browser event target changed caught');
					// RESEARCH must delay 100ms to get the correct url, don't know why
					setTimeout(async () => {
						const page = await target.page();
						const uuid = findUuidOfPage(page, allPages);
						sendRecordedEvent(JSON.stringify({ type: 'page-switched', url: page.url(), uuid }));
					}, 100);
				}
			});
			browser.on('targetdestroyed', async target => {
				if (target.type() === 'page') {
					console.log('browser event target destroyed caught');
					const page = await target.page();
					const allClosed = isAllRelatedPagesClosed(page, flowKey);
					const uuid = deletePageByUuid(page, allPages);
					if (uuid) {
						sendRecordedEvent(JSON.stringify({ type: 'page-closed', url: page.url(), uuid, allClosed }));
					}
				}
			});

			await recordRemoteRequests(page, flowKey, allPages);
			// TODO record file
			await controlPage(page, { device, flowKey }, allPages);

			await page.goto(url, { waitUntil: 'domcontentloaded' });
			try {
				await page.waitForNavigation({ waitUntil: 'domcontentloaded' });
			} catch (e) {
				console.error('Failed to wait for navigation dom content loaded.');
				console.error(e);
			}
		})();
	});
	const disconnectPuppeteer = async (flowKey, close) => {
		const browser = browsers[flowKey];
		const pages = await browser.pages();
		const coverages = await pages.reduce(async (coverages, page) => {
			let jsCoverage = [];
			let cssCoverage = [];
			try {
				jsCoverage = await page.coverage.stopJSCoverage();
			} catch (e) {
				console.error(e);
			}
			try {
				cssCoverage = await page.coverage.stopCSSCoverage();
			} catch (e) {
				console.error(e);
			}
			return coverages.concat(jsCoverage).concat(cssCoverage);
		}, []);
		try {
			await browser.disconnect();
		} catch (e) {
			console.error('Failed to disconnect from brwoser.');
			console.error(e);
		}
		if (close) {
			try {
				await browser.close();
				delete browsers[flowKey];
			} catch (e) {
				console.error('Failed to close brwoser.');
				console.error(e);
			}
		}
		return coverages;
	};
	ipcMain.on('disconnect-puppeteer', (event, arg) => {
		(async () => {
			const { flowKey } = arg;
			const coverages = await disconnectPuppeteer(flowKey);
			pti.write(coverages);
		})();
	});
	ipcMain.on('abolish-puppeteer', (event, arg) => {
		(async () => {
			const { flowKey } = arg;
			const coverages = await disconnectPuppeteer(flowKey, true);
			pti.write(coverages);
		})();
	});
	ipcMain.on('capture-screen', (event, arg) => {
		(async () => {
			const { flowKey, uuid } = arg;
			const browser = browsers[flowKey];
			if (browser == null) {
				event.reply(`screen-captured-${flowKey}`, { error: 'Browser not found.' });
				return;
			}
			const pages = await browser.pages();
			const page = pages.find(async page => {
				return uuid === (await page.evaluate(() => window.$lhGetUuid()));
			});
			if (page == null) {
				event.reply(`screen-captured-${flowKey}`, { error: 'Page not found.' });
			} else {
				try {
					const base64 = await page.screenshot({ encoding: 'base64' });
					event.reply(`screen-captured-${flowKey}`, { image: base64 });
				} catch (e) {
					console.error(e);
					event.reply(`screen-captured-${flowKey}`, { error: e.message });
				}
			}
		})();
	});
	ipcMain.on('start-pick-dom', (event, arg) => {
		(async () => {
			const { flowKey, uuid } = arg;
			const browser = browsers[flowKey];
			if (browser == null) {
				event.reply('dom-on-page-picked', { error: 'browser not found.' });
				return;
			}
			const pages = await browser.pages();
			const page = pages.find(async page => {
				return uuid === (await page.evaluate(() => window.$lhGetUuid()));
			});
			if (page == null) {
				event.reply('dom-on-page-picked', { error: 'page not found.' });
			} else {
				await page.evaluate(() => {
					const mask = document.createElement('div');
					mask.id = '$lh-mask';
					mask.style.position = 'fixed';
					mask.style.top = 0;
					mask.style.left = 0;
					mask.style.bottom = 0;
					mask.style.right = 0;
					mask.style.backgroundColor = 'rgba(0,0,0,0.3)';
					mask.style.zIndex = 9999999;

					const topBorder = document.createElement('div');
					const rightBorder = document.createElement('div');
					const bottomBorder = document.createElement('div');
					const leftBorder = document.createElement('div');
					[topBorder, bottomBorder].forEach(element => (element.style.height = '2px'));
					[rightBorder, leftBorder].forEach(element => (element.style.width = '2px'));
					[topBorder, rightBorder, bottomBorder, leftBorder].forEach(element => {
						element.style.backgroundColor = 'red';
						element.style.position = 'fixed';
						element.style.zIndex = 10000000;
						element.style.transition = 'all 200ms ease';
						mask.appendChild(element);
					});

					mask.addEventListener('mousemove', event => {
						const { clientX, clientY } = event;
						const elements = document.elementsFromPoint(clientX, clientY);
						if (elements.length > 1) {
							const element = elements[1];
							const { top, left, height, width } = element.getBoundingClientRect();
							// console.log(top, left, height, width, element);
							topBorder.style.left = `${left - 6}px`;
							topBorder.style.top = `${top - 6}px`;
							topBorder.style.width = `${width + 12}px`;
							rightBorder.style.left = `${left + width + 4}px`;
							rightBorder.style.top = `${top - 6}px`;
							rightBorder.style.height = `${height + 12}px`;
							bottomBorder.style.left = `${left - 6}px`;
							bottomBorder.style.top = `${top + height + 4}px`;
							bottomBorder.style.width = `${width + 12}px`;
							leftBorder.style.left = `${left - 6}px`;
							leftBorder.style.top = `${top - 6}px`;
							leftBorder.style.height = `${height + 12}px`;
						}
					});
					document.body.appendChild(mask);
				});
				await page.bringToFront();
			}
		})();
	});
};

const destory = () => {
	console.info('destory all puppeteer browsers.');
	Object.keys(browsers).forEach(async key => {
		console.info(`destory puppeteer browser[${key}]`);
		const browser = browsers[key];
		delete browsers[key];
		try {
			await browser.disconnect();
		} catch {
			// ignore
		}
		try {
			await browser.close();
		} catch {
			// ignore
		}
	});
};

module.exports = { initialize: () => launch(), destory };
